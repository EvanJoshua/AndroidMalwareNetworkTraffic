/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package neuralnetwork;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.concurrent.Semaphore;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import weka.attributeSelection.PrincipalComponents;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;

/**
 * trainingData
 *
 * @author asus
 */
public class Driver {

    static int numberOfEpoch = 100;
    static int numberOfCombinationFeatures[] = {22, 15, 18, 20, 18, 16, 27, 13};
    static double trainingData[][][];
    static double testingData[][][];
    static double maxValueOfFeatures[];
    static NeuralNetwork neuralNetwork = null;
    static String pendekatan[] = {"PCA", "Literatur", "LiteraturAndByteBased", "LiteraturAndPacketBased",
        "LiteraturAndTimeBased", "LiteraturFlowBased", "LiteraturAndAllBased", "Pengurangan"};
    static double learningRate[] = {0.1, 0.05, 0.01};
    static int hiddenNeuron[] = {4, 5, 6, 12};

    public static void convertToLatex(String file) throws IOException {
        /*
            Function untuk ngeparse output biar langsung ke format table latex
         */

        PrintWriter writer = null;
        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
        writer = new PrintWriter(new BufferedWriter(new FileWriter("latexFormat.txt", true)));
        String line;
        int epoch = 100;
        for (int i = 0; i < 36; i++) {
            String value[] = new String[3];
            double fScore = 0;
            if (i % 9 == 0 && i != 0) {
                writer.println();
            }
            line = bufferedReader.readLine();
            for (int j = 0; j < 3; j++) {
                value[j] = bufferedReader.readLine();
            }
            line = bufferedReader.readLine();
            fScore = getFScore(Double.parseDouble(value[1]), Double.parseDouble(value[2]));
            if (i % 3 == 0 && i != 0) {
                epoch = 100;
            }
            writer.println("& & " + epoch + " & " + String.format("%.2f", 100 * Double.parseDouble(value[0])) + "\\% & " + String.format("%.2f", 100 * Double.parseDouble(value[1]))
                    + "\\% & " + String.format("%.2f", 100 * Double.parseDouble(value[2])) + "\\% & " + String.format("%.4f", fScore) + "\\\\");

            epoch += 100;
        }
        writer.close();
        bufferedReader.close();
    }

    public static double getFScore(double presicion, double recall) {
        /*
            Function untuk f1-score
         */

        double result = 0;
        result = 2 * presicion * recall / (presicion + recall);
        return result;
    }

    public static void setMaxValue(String[] line) {
        /*
            Function buat mengambil max value dari tiap fitur
         */

        double featureValue;
        for (int i = 0; i < line.length; i++) {
            featureValue = Double.parseDouble(line[i]);
            if (featureValue == 0) {
                featureValue = 1;
            }
            maxValueOfFeatures[i] = featureValue;
        }
    }

//    public static double[][][] getData(String file, String type, int numberOfFeatures) throws IOException {
//        /*
//            Fungsi buat ambil data dari file
//         */
//
//        BufferedReader bufferedReader = null;
//        String line; // for read every line
//        String[] maxValue;
//        String dataAfterSplit[];
//        String result = "";
//        double data[][][];
//        int counter = 0;
//        int totalData = 0;
//        double dataDouble[];
//        double targetResult[];
//
//        bufferedReader = new BufferedReader(new FileReader(file));
//        line = bufferedReader.readLine(); // read for max value in features
//        maxValue = line.split(","); // split line into array
//        maxValueOfFeatures = new double[maxValue.length];
//
//        setMaxValue(maxValue);//for getting max value of features
//
//        try {
//            while (line != null) {
//                totalData++;
//                line = bufferedReader.readLine();
//            }
//            data = new double[totalData - 1][2][numberOfFeatures];
//            /* [counter - 1] = total data, [2] = features and target results, [maxValueOfFeatures.length] = number of features*/
//
//            bufferedReader = new BufferedReader(new FileReader(file));
//            line = bufferedReader.readLine();//skip max value in csv file
//            line = bufferedReader.readLine();
//
//            while (line != null) {
//                dataAfterSplit = line.split(",");
//                dataDouble = new double[numberOfFeatures];
//                if (type.equals("PCA")) {
//                    dataDouble = new double[dataAfterSplit.length - 1];
//                    for (int i = 0; i < dataAfterSplit.length - 1; i++) {
//                        dataDouble[i] = Double.parseDouble(dataAfterSplit[i]) / maxValueOfFeatures[i];
//                    }
//                } else {
//                    dataDouble = getSelectedFeatures(dataAfterSplit, type, numberOfFeatures);
//                }
//
//                targetResult = new double[3];
//                result = dataAfterSplit[dataAfterSplit.length - 1];
//                switch (result) {
//                    case "benign":
//                        targetResult[0] = 1;
//                        targetResult[1] = 0;
//                        targetResult[2] = 0;
//                        break;
//                    case "asware":
//                        targetResult[0] = 0;
//                        targetResult[1] = 1;
//                        targetResult[2] = 0;
//                        break;
//                    case "GeneralMalware":
//                        targetResult[0] = 0;
//                        targetResult[1] = 0;
//                        targetResult[2] = 1;
//                        break;
//                    default:
//                        break;
//                }
//                data[counter][0] = dataDouble;
//                data[counter][1] = targetResult;
//                line = bufferedReader.readLine();
//                counter++;
//            }
//        } finally {
//            bufferedReader.close();
//        }
//        return data;
//    }
    public static double[] PCA(String file) {
        try {
            // Load the Data.
            ConverterUtils.DataSource source = new ConverterUtils.DataSource(file);
            Instances data = source.getDataSet();

            // Perform PCA.
            PrincipalComponents pca = new PrincipalComponents();
            pca.setVarianceCovered(1.0);

            pca.setCenterData(true);
            pca.setTransformBackToOriginal(false);
            pca.buildEvaluator(data);

            Instances transformedData = pca.transformedData(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static double[][][] getData(String file, String type, Boolean status[]) throws IOException {
        /*
            Fungsi buat ambil data dari file
         */

        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
        ArrayList<Double> features = new ArrayList<>();
        ArrayList<ArrayList<Double>> dataBeforePCA = new ArrayList<>();
        String line; // for read every line
        String[] maxValue;
        String dataAfterSplit[];
        String result = "";
        double dataAfterPCA[][][];
        double targetResult[];
        int counter = 0;
        int totalData = 0;
        int numberOfFeatures = 0;

        line = bufferedReader.readLine(); // read for max value in features
        maxValue = line.split(","); // split line into array
        maxValueOfFeatures = new double[maxValue.length];

        setMaxValue(maxValue);//for getting max value of features

        try {
            while (line != null) {
                totalData++;
                line = bufferedReader.readLine();
            }

            bufferedReader = new BufferedReader(new FileReader(file));
            line = bufferedReader.readLine();//skip max value in csv file
            line = bufferedReader.readLine();

            while (line != null) {
                dataAfterSplit = line.split(",");
                if (type.equals("PCA")) {
                    for (int i = 0; i < dataAfterSplit.length - 1; i++) {
                        features.add(Double.parseDouble(dataAfterSplit[i]) / maxValueOfFeatures[i]);
                    }
                } else {
                    Double temp[] = getSelectedFeatures(dataAfterSplit, status);
                    numberOfFeatures = temp.length;
                    for (int i = 0; i < temp.length; i++) {
                        features.add(temp[i]);
                    }
                }
                dataBeforePCA.add(features);
                features = new ArrayList<>();
                line = bufferedReader.readLine();
                counter++;
            }
//            for (int i = 0; i < 100; i++) {
//                
//                targetResult = new double[3];
//                result = dataAfterSplit[dataAfterSplit.length - 1];
//                switch (result) {
//                    case "benign":
//                        targetResult[0] = 1;
//                        targetResult[1] = 0;
//                        targetResult[2] = 0;
//                        break;
//                    case "asware":
//                        targetResult[0] = 0;
//                        targetResult[1] = 1;
//                        targetResult[2] = 0;
//                        break;
//                    case "GeneralMalware":
//                        targetResult[0] = 0;
//                        targetResult[1] = 0;
//                        targetResult[2] = 1;
//                        break;
//                    default:
//                        break;
//                }
//                data[counter][0] = Stream.of(features.toArray(new Double[features.size()])).mapToDouble(Double::doubleValue).toArray();
//                data[counter][1] = targetResult;
//            }
        } finally {
            bufferedReader.close();
        }
        /* [counter - 1] = total data, [2] = features and target results, [maxValueOfFeatures.length] = number of features*/
        dataAfterPCA = new double[totalData - 1][2][numberOfFeatures];
        return dataAfterPCA;
    }

    public static Double[] getSelectedFeatures(String data[], Boolean status[]) {
        ArrayList<Double> features = new ArrayList<>();
        if (status[0]) {
            features.add(Double.parseDouble(data[2]) / maxValueOfFeatures[2]);
        }
        if (status[1]) {
            features.add(Double.parseDouble(data[4]) / maxValueOfFeatures[4]);
        }
        if (status[2]) {
            features.add((Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
                    / (maxValueOfFeatures[8] + maxValueOfFeatures[9]));
        }
        if (status[3]) {
            features.add((Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
                    / (maxValueOfFeatures[68] + maxValueOfFeatures[70]));
        }
        if (status[4]) {
            features.add(Double.parseDouble(data[58]) / maxValueOfFeatures[58]);
        }
        if (status[5]) {
            features.add(Double.parseDouble(data[47]) / maxValueOfFeatures[47]);
        }
        if (status[6]) {
            features.add(Double.parseDouble(data[21]) / maxValueOfFeatures[21]);
        }
        if (status[7]) {
            features.add(Double.parseDouble(data[20]) / maxValueOfFeatures[20]);
        }
        if (status[8]) {
            features.add(Double.parseDouble(data[22]) / maxValueOfFeatures[22]);
        }
        if (status[9]) {
            features.add(Double.parseDouble(data[23]) / maxValueOfFeatures[23]);
        }
        if (status[10]) {
            features.add((Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
                    / (maxValueOfFeatures[8] / maxValueOfFeatures[9]));
        }
        if (status[11]) {
            features.add((Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
                    / (maxValueOfFeatures[68] / maxValueOfFeatures[70]));
        }
        if (status[12]) {
            features.add((Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
                    / (maxValueOfFeatures[26] / maxValueOfFeatures[31]));
        }
        if (status[13]) {
            features.add((Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
                    / (maxValueOfFeatures[68] / maxValueOfFeatures[70]));
        }
        if (status[14]) {
            features.add((Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
                    / (maxValueOfFeatures[26] / maxValueOfFeatures[31]));
        }
        if (status[15]) {
            features.add(Double.parseDouble(data[49]) / maxValueOfFeatures[49]);
        }
        if (status[16]) {
            features.add(Double.parseDouble(data[75]) / maxValueOfFeatures[75]);
        }
        if (status[17]) {
            features.add(Double.parseDouble(data[28]) / maxValueOfFeatures[28]);
        }
        if (status[18]) {
            features.add(Double.parseDouble(data[33]) / maxValueOfFeatures[33]);
        }
        if (status[19]) {
            features.add(Double.parseDouble(data[42]) / maxValueOfFeatures[42]);
        }
        if (status[20]) {
            features.add(Double.parseDouble(data[10]) / maxValueOfFeatures[10]);
        }
        if (status[21]) {
            features.add(Double.parseDouble(data[43]) / maxValueOfFeatures[43]);
        }
        if (status[22]) {
            features.add(Double.parseDouble(data[45]) / maxValueOfFeatures[45]);
        }
        if (status[23]) {
            features.add(Double.parseDouble(data[9]) / maxValueOfFeatures[9]);
        }
        if (status[24]) {
            features.add(Double.parseDouble(data[11]) / maxValueOfFeatures[11]);
        }
        if (status[25]) {
            features.add(Double.parseDouble(data[12]) / maxValueOfFeatures[12]);
        }
        if (status[26]) {
            features.add(Double.parseDouble(data[48]) / maxValueOfFeatures[48]);
        }
        return features.toArray(new Double[features.size()]);
    }

//    public static double[] getSelectedFeatures(String[] data, String type, int numberOfFeatures) {
//        /*
//            Fungsi buat ambil fitur yang dipakai nya
//         */
//
//        double dataDouble[] = new double[numberOfFeatures];
//        switch (type) {
//            case "LiteraturAndByteBased":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[3] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[4] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[5] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[6] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[7] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[8] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[9] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[10] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[11] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[12] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[13] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[14] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[15] = Double.parseDouble(data[11]) / maxValueOfFeatures[11];
//                dataDouble[16] = Double.parseDouble(data[12]) / maxValueOfFeatures[12];
//                dataDouble[17] = Double.parseDouble(data[48]) / maxValueOfFeatures[48];
//                break;
//            case "LiteraturAndPacketBased":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[3] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[4] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[5] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[6] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[7] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[8] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[9] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[10] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[11] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[12] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[13] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[14] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[15] = Double.parseDouble(data[42]) / maxValueOfFeatures[42];
//                dataDouble[16] = Double.parseDouble(data[10]) / maxValueOfFeatures[10];
//                dataDouble[17] = Double.parseDouble(data[43]) / maxValueOfFeatures[43];
//                dataDouble[18] = Double.parseDouble(data[45]) / maxValueOfFeatures[45];
//                dataDouble[19] = Double.parseDouble(data[9]) / maxValueOfFeatures[9];
//                break;
//            case "LiteraturAndTimeBased":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[3] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[4] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[5] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[6] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[7] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[8] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[9] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[10] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[11] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[12] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[13] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[14] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[15] = Double.parseDouble(data[75]) / maxValueOfFeatures[75];
//                dataDouble[16] = Double.parseDouble(data[28]) / maxValueOfFeatures[28];
//                dataDouble[17] = Double.parseDouble(data[33]) / maxValueOfFeatures[33];
//                break;
//            case "LiteraturFlowBased":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[3] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[4] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[5] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[6] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[7] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[8] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[9] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[10] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[11] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[12] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[13] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[14] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[15] = Double.parseDouble(data[49]) / maxValueOfFeatures[49];
//
//                break;
//            case "LiteraturAndAllBased":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[3] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[4] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[5] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[6] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[7] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[8] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[9] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[10] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[11] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[12] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[13] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[14] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                dataDouble[15] = Double.parseDouble(data[49]) / maxValueOfFeatures[49];
//                dataDouble[16] = Double.parseDouble(data[75]) / maxValueOfFeatures[75];
//                dataDouble[17] = Double.parseDouble(data[28]) / maxValueOfFeatures[28];
//                dataDouble[18] = Double.parseDouble(data[33]) / maxValueOfFeatures[33];
//                dataDouble[19] = Double.parseDouble(data[42]) / maxValueOfFeatures[42];
//                dataDouble[20] = Double.parseDouble(data[10]) / maxValueOfFeatures[10];
//                dataDouble[21] = Double.parseDouble(data[43]) / maxValueOfFeatures[43];
//                dataDouble[22] = Double.parseDouble(data[45]) / maxValueOfFeatures[45];
//                dataDouble[23] = Double.parseDouble(data[9]) / maxValueOfFeatures[9];
//                dataDouble[24] = Double.parseDouble(data[11]) / maxValueOfFeatures[11];
//                dataDouble[25] = Double.parseDouble(data[12]) / maxValueOfFeatures[12];
//                dataDouble[26] = Double.parseDouble(data[48]) / maxValueOfFeatures[48];
//                break;
//            case "Literatur":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = Double.parseDouble(data[5]) / maxValueOfFeatures[5];
//                dataDouble[3] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[4] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[5] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[6] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[7] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[8] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[9] = Double.parseDouble(data[7]) / maxValueOfFeatures[7];
//                dataDouble[10] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[11] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[12] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[13] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[14] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                break;
//            case "Pengurangan":
//                dataDouble[0] = Double.parseDouble(data[2]) / maxValueOfFeatures[2];
//                dataDouble[1] = Double.parseDouble(data[4]) / maxValueOfFeatures[4];
//                dataDouble[2] = (Double.parseDouble(data[8]) + Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] + maxValueOfFeatures[9]);
//                dataDouble[3] = (Double.parseDouble(data[68]) + Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] + maxValueOfFeatures[70]);
//                dataDouble[4] = Double.parseDouble(data[58]) / maxValueOfFeatures[58];
//                dataDouble[5] = Double.parseDouble(data[47]) / maxValueOfFeatures[47];
//                dataDouble[6] = Double.parseDouble(data[21]) / maxValueOfFeatures[21];
//                dataDouble[7] = Double.parseDouble(data[20]) / maxValueOfFeatures[20];
//                dataDouble[8] = Double.parseDouble(data[22]) / maxValueOfFeatures[22];
//                dataDouble[9] = Double.parseDouble(data[23]) / maxValueOfFeatures[23];
//                dataDouble[10] = (Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9]))
//                        / (maxValueOfFeatures[8] / maxValueOfFeatures[9]);
//                dataDouble[11] = (Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70]))
//                        / (maxValueOfFeatures[68] / maxValueOfFeatures[70]);
//                dataDouble[12] = (Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31]))
//                        / (maxValueOfFeatures[26] / maxValueOfFeatures[31]);
//                break;
//            default:
//                break;
//        }
//        return dataDouble;
//    }
    public static int getNumberOfEpoch() {
        return numberOfEpoch;
    }

    public static void setNumberOfEpoch(int numberOfEpoch) {
        Driver.numberOfEpoch = numberOfEpoch;
    }

    public static int[] getNumberOfCombinationFeatures() {
        return numberOfCombinationFeatures;
    }

    public static void setNumberOfCombinationFeatures(int[] numberOfCombinationFeatures) {
        Driver.numberOfCombinationFeatures = numberOfCombinationFeatures;
    }

    public static double[][][] getTrainingData() {
        return trainingData;
    }

    public static void setTrainingData(double[][][] trainingData) {
        Driver.trainingData = trainingData;
    }

    public static double[][][] getTestingData() {
        return testingData;
    }

    public static void setTestingData(double[][][] testingData) {
        Driver.testingData = testingData;
    }

    public static double[] getMaxValueOfFeatures() {
        return maxValueOfFeatures;
    }

    public static void setMaxValueOfFeatures(double[] maxValueOfFeatures) {
        Driver.maxValueOfFeatures = maxValueOfFeatures;
    }

    public static NeuralNetwork getNeuralNetwork() {
        return neuralNetwork;
    }

    public static void setNeuralNetwork(NeuralNetwork neuralNetwork) {
        Driver.neuralNetwork = neuralNetwork;
    }

    public static String[] getPendekatan() {
        return pendekatan;
    }

    public static void setPendekatan(String[] pendekatan) {
        Driver.pendekatan = pendekatan;
    }

    public static double[] getLearningRate() {
        return learningRate;
    }

    public static void setLearningRate(double[] learningRate) {
        Driver.learningRate = learningRate;
    }

    public static int[] getHiddenNeuron() {
        return hiddenNeuron;
    }

    public static void setHiddenNeuron(int[] hiddenNeuron) {
        Driver.hiddenNeuron = hiddenNeuron;
    }

    public static void test(int indexPendekatan, int indexLearningRate, int indexHiddenNeuron, int epoch) throws FileNotFoundException, UnsupportedEncodingException, IOException {
        double accuracy = 0;
        double precission = 0;
        double recall = 0;
        NeuralNetwork.truePositive = 0;
        NeuralNetwork.trueNegative = 0;
        NeuralNetwork.falsePositive = 0;
        NeuralNetwork.falseNegative = 0;
        NeuralNetwork.predictAdware = 0;
        NeuralNetwork.predictBenign = 0;
        NeuralNetwork.predictGeneralMalware = 0;
        PrintWriter writer = null;
        PrintWriter writerDetail = null;
        IntStream.range(0, Driver.trainingData.length).forEach(i
                -> neuralNetwork.forwardprop(Driver.trainingData[i][0], Driver.trainingData[i][1])
        );

        accuracy = (double) (NeuralNetwork.trueNegative + NeuralNetwork.truePositive)
                / (double) (NeuralNetwork.trueNegative + NeuralNetwork.truePositive + NeuralNetwork.falseNegative + NeuralNetwork.falsePositive);
        precission = (double) NeuralNetwork.truePositive / (double) (NeuralNetwork.truePositive + NeuralNetwork.falsePositive);
        recall = (double) NeuralNetwork.truePositive / (double) (NeuralNetwork.truePositive + NeuralNetwork.falseNegative);
        System.out.println("True +: " + NeuralNetwork.truePositive);
        System.out.println("True -: " + NeuralNetwork.trueNegative);
        System.out.println("False +: " + NeuralNetwork.falsePositive);
        System.out.println("False -: " + NeuralNetwork.falseNegative);
        System.out.println("Accuracy: " + accuracy);
        System.out.println("Precission: " + precission);
        System.out.println("Recall: " + recall);
        writer = new PrintWriter(new BufferedWriter(new FileWriter("weight/result.txt", true)));
        writerDetail = new PrintWriter(new BufferedWriter(new FileWriter("weight/detail.txt", true)));

        writerDetail.println(pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch);
        writerDetail.println("True +: " + NeuralNetwork.truePositive);
        writerDetail.println("True -: " + NeuralNetwork.trueNegative);
        writerDetail.println("False +: " + NeuralNetwork.falsePositive);
        writerDetail.println("False -: " + NeuralNetwork.falseNegative);
        writerDetail.println("Accuracy: " + accuracy);
        writerDetail.println("Precission: " + precission);
        writerDetail.println("Recall: " + recall);
        writerDetail.println("Predict Benign: " + NeuralNetwork.predictBenign);
        writerDetail.println("Predict Adware: " + NeuralNetwork.predictAdware);
        writerDetail.println("Predict GeneralMalware: " + NeuralNetwork.predictGeneralMalware);
        writerDetail.println();

        writer.println(pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch);

        writer.println(accuracy);
        writer.println(precission);
        writer.println(recall);
        writer.println();

        writer.close();
        writerDetail.close();
    }

    public static void train(int indexPendekatan, int indexLearningRate, int indexHiddenNeuron, int epoch) throws FileNotFoundException, UnsupportedEncodingException {
        PrintWriter writerHiddenOutput = null;
        PrintWriter writerInputHidden = null;
        Neuron[] iNeuron = NeuralNetwork.layers[0].getNeurons();
        Neuron[] hNeuron = NeuralNetwork.layers[1].getNeurons();
        Neuron[] oNeuron = NeuralNetwork.layers[2].getNeurons();
        String pendekatanPath = "weight/" + pendekatan[indexPendekatan];
        File directoryPendekatan = new File(pendekatanPath);

        //Pelatihan sebanyak epoch
        IntStream.range(0, numberOfEpoch).forEach(i -> {
            System.out.println("[epoch " + i + "]");
            IntStream.range(0, Driver.trainingData.length).forEach(j -> {
                try {
                    Driver.neuralNetwork
                            .forwardprop(Driver.trainingData[j][0], Driver.trainingData[j][1])
                            .backpropError(Driver.trainingData[j][1]);
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Driver.class.getName()).log(Level.SEVERE, null, ex);
                } catch (UnsupportedEncodingException ex) {
                    Logger.getLogger(Driver.class.getName()).log(Level.SEVERE, null, ex);
                }
            });
        });

        //check folder sudah ada atau belum
        if (!directoryPendekatan.exists()) {
            directoryPendekatan.mkdir();
        }

        //write ke dalam file dengan folder sesuai tipenya
        for (int i = 0; i < NeuralNetwork.layers[NeuralNetwork.layers.length - 1].getNeurons().length; i++) {
            String path = "weight/" + pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                    + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch;
            File directory = new File(path);
            if (!directory.exists()) {
                directory.mkdir();
            }
            writerHiddenOutput = new PrintWriter(path + "/weight_hidden_output_" + (i + 1) + ".txt", "UTF-8");
            for (int j = 0; j < oNeuron[i].getWeights().length; j++) {
                writerHiddenOutput.println(oNeuron[i].getWeights()[j]);
            }
            writerHiddenOutput.close();
        }

        for (int i = 0; i < NeuralNetwork.numbOfHiddenNeurons; i++) {
            String path = "weight/" + pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                    + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch;

            writerInputHidden = new PrintWriter(path + "/weight_input_hidden_" + (i + 1) + ".txt", "UTF-8");
            for (int j = 0; j < hNeuron[i].getWeights().length; j++) {
                writerInputHidden.println(hNeuron[i].getWeights()[j]);
            }
            writerInputHidden.close();
        }
        System.out.println("Training has done");
    }

    public static void main(String[] args) throws IOException {
//        convertToLatex("nonLatex.txt");
        int epoch = 100;
        String fileTraining[] = {"PCATraining.csv", "TrainingData.csv"};
        String fileTesting[] = {"PCATesting.csv", "TestingData.csv"};
//        "PCA", "Literatur", "LiteraturAndByteBased", "LiteraturAndPacketBased",
//        "LiteraturAndTimeBased", "LiteraturFlowBased", "LiteraturAndAllBased", "Pengurangan"
        for (int i = 2; i < 3; i++) {
            /*
                int i = 7;//pendekatan
                int k = 3;//hidden neuron
                int j = 1;//learning rate
             */
            if (i == 0) {
                trainingData = getData(fileTraining[0], pendekatan[i], numberOfCombinationFeatures[i]);
                testingData = getData(fileTesting[0], pendekatan[i], numberOfCombinationFeatures[i]);
            } else {
                trainingData = getData(fileTraining[1], pendekatan[i], numberOfCombinationFeatures[i]);
                testingData = getData(fileTesting[1], pendekatan[i], numberOfCombinationFeatures[i]);
            }
            for (int k = 0; k < hiddenNeuron.length; k++) {
                for (int j = 0; j < learningRate.length; j++) {

                    NeuralNetwork.LEARNING_RATE = learningRate[j];
                    NeuralNetwork.numbOfHiddenNeurons = hiddenNeuron[k];

                    neuralNetwork = new NeuralNetwork();
                    System.out.println(pendekatan[i] + " LR: " + learningRate[j] + " hidden neuron: " + hiddenNeuron[k] + " epoch: " + epoch);
                    train(i, j, k, epoch);
                    test(i, j, k, epoch);
                    System.out.println(pendekatan[i] + " LR: " + learningRate[j] + " hidden neuron: " + hiddenNeuron[k] + " epoch: " + (epoch + 100));
                    train(i, j, k, epoch + 100);
                    test(i, j, k, epoch + 100);
                    System.out.println(pendekatan[i] + " LR: " + learningRate[j] + " hidden neuron: " + hiddenNeuron[k] + " epoch: " + (epoch + 200));
                    train(i, j, k, epoch + 200);
                    test(i, j, k, epoch + 200);
                }
            }
        }
    }
}
