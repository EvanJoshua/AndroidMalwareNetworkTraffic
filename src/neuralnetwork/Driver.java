/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package neuralnetwork;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import weka.filters.unsupervised.attribute.PrincipalComponents;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;
import weka.filters.Filter;

/**
 * trainingData
 *
 * @author asus
 */
public class Driver {

    static int numberOfEpoch = 100;
    static int numberOfFeatures = 0;
    static int numberOfFeaturesPCA = 0;
    static double trainingData[][][];
    static double testingData[][][];
    static double maxValueOfFeatures[];
    static NeuralNetwork neuralNetwork = null;
    static String weightPath = "";
    static String actionType = "train";

    public static int getNumberOfFeatures() {
        return numberOfFeatures;
    }

    public static void setNumberOfFeatures(int numberOfFeatures) {
        Driver.numberOfFeatures = numberOfFeatures;
    }

    public static String getWeightPath() {
        return weightPath;
    }

    public static void setWeightPath(String weightPath) {
        Driver.weightPath = weightPath;
    }

    public static String getActionType() {
        return actionType;
    }

    public static void setActionType(String actionType) {
        Driver.actionType = actionType;
    }

    public static NeuralNetwork getNeuralNetwork() {
        return neuralNetwork;
    }

    public static void setNeuralNetwork(NeuralNetwork neuralNetwork) {
        Driver.neuralNetwork = neuralNetwork;
    }

    public static int getNumberOfEpoch() {
        return numberOfEpoch;
    }

    public static void setNumberOfEpoch(int numberOfEpoch) {
        Driver.numberOfEpoch = numberOfEpoch;
    }

    public static double[][][] getTrainingData() {
        return trainingData;
    }

    public static void setTrainingData(double[][][] trainingData) {
        Driver.trainingData = trainingData;
    }

    public static double[][][] getTestingData() {
        return testingData;
    }

    public static void setTestingData(double[][][] testingData) {
        Driver.testingData = testingData;
    }

    public static double[] getMaxValueOfFeatures() {
        return maxValueOfFeatures;
    }

    public static double getFScore(double presicion, double recall) {
        double result = 0;
        result = 2 * presicion * recall / (presicion + recall);
        return result;
    }

    public static Instances PCA() {
        String file = "temp.csv";
//        String file = "D:\\StupidYou\\Course\\TA\\Datasets\\TrainingData60.csv";
        Instances data = null;

        try {
            // Load the Data.
            ConverterUtils.DataSource source = new ConverterUtils.DataSource(file);
            data = source.getDataSet();

            // Perform PCA.
            PrincipalComponents pca = new PrincipalComponents();
            pca.setVarianceCovered(0.95);
            if (Driver.getActionType().equals("test")) {

                pca.setMaximumAttributes(numberOfFeaturesPCA);
            }
            pca.setCenterData(false);

            pca.setInputFormat(data);
            data = Filter.useFilter(data, pca);
            if (Driver.getActionType().equals("train")) {

                numberOfFeaturesPCA = data.get(0).toString().split(",").length;
                System.out.println("train:" + numberOfFeaturesPCA);
            } else {
                System.out.println("test: " + data.get(0).toString().split(",").length);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }

    public static int countFeatures(Boolean status[]) {
        int totalFeatures = 0;
        for (int i = 0; i < status.length; i++) {
            if (status[i]) {
                totalFeatures++;
            }
        }
        return totalFeatures;
    }

    public static void saveToFile(String header[], ArrayList<ArrayList<Double>> dataBeforePCA) throws FileNotFoundException {
        PrintWriter pw = new PrintWriter(new File("temp.csv"));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < header.length - 1; i++) {
            sb.append(header[i]);
            sb.append(',');
        }
        sb.append(header[header.length - 1]);
        sb.append('\n');

        for (int i = 0; i < dataBeforePCA.size(); i++) {
            for (int j = 0; j < dataBeforePCA.get(i).size() - 1; j++) {

                sb.append(dataBeforePCA.get(i).get(j));
                sb.append(',');
            }
            System.out.println("lk " + i);
            sb.append(dataBeforePCA.get(i).get(dataBeforePCA.get(i).size() - 1));
            sb.append('\n');
        }

        pw.write(sb.toString());
        pw.close();
        System.out.println("Save To File Done!");
    }

    public static void setMaxValue(String[] line) {
        double featureValue;
        maxValueOfFeatures = new double[line.length];
        for (int i = 0; i < line.length; i++) {
            featureValue = Double.parseDouble(line[i]);
            if (featureValue == 0) {
                featureValue = 1;
            }
            maxValueOfFeatures[i] = featureValue;
        }
    }

    public static ArrayList<ArrayList<Double>> normalize(ArrayList<ArrayList<Double>> data) throws FileNotFoundException, IOException {
        BufferedReader bufferedReader = new BufferedReader(new FileReader("maxValueOfNormalFeatures.csv"));
        String line[];
        line = bufferedReader.readLine().split(",");
        maxValueOfFeatures = new double[line.length];

        for (int i = 0; i < line.length; i++) {
            maxValueOfFeatures[i] = Double.parseDouble(line[i]);
        }

        for (int i = 0; i < data.size(); i++) {
            for (int j = 0; j < data.get(i).size(); j++) {
                data.get(i).set(j, data.get(i).get(j) / maxValueOfFeatures[j]);
            }
        }
        return data;
    }

    public static double[][][] getData(String file, String type, Boolean status[]) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
        ArrayList<Double> features = new ArrayList<>();
        String line;
        String dataAfterSplit[];
        String result;
        String[] dataMaxValue;
        double dataFinal[][][];
        double targetResult[];
        int counter = 0;
        int totalData = 0;

        line = bufferedReader.readLine();
        numberOfFeatures = countFeatures(status);
        try {
            while (line != null) {
                totalData++;
                line = bufferedReader.readLine();
            }
            /* [counter - 1] = total data, [2] = features and target results, [maxValueOfFeatures.length] = number of features*/
            dataFinal = new double[totalData - 1][2][numberOfFeatures];
            bufferedReader = new BufferedReader(new FileReader(file));
            line = bufferedReader.readLine();

            dataMaxValue = line.split(",");
            setMaxValue(dataMaxValue);

            line = bufferedReader.readLine();
            while (line != null) {
                dataAfterSplit = line.split(",");
                targetResult = new double[3];
                result = dataAfterSplit[dataAfterSplit.length - 1];
                if (type.equals("All")) {
                    for (int i = 0; i < dataAfterSplit.length - 1; i++) {
                        features.add(Double.parseDouble(dataAfterSplit[i]) / maxValueOfFeatures[i]);
                    }
                } else {
                    Double temp[] = getSelectedFeatures(dataAfterSplit, status);
                    for (int i = 0; i < temp.length; i++) {
                        features.add(temp[i]);
                    }
                }
                switch (result) {
                    case "benign":
                        targetResult[0] = 1;
                        targetResult[1] = 0;
                        targetResult[2] = 0;
                        break;
                    case "asware":
                        targetResult[0] = 0;
                        targetResult[1] = 1;
                        targetResult[2] = 0;
                        break;
                    case "GeneralMalware":
                        targetResult[0] = 0;
                        targetResult[1] = 0;
                        targetResult[2] = 1;
                        break;
                    default:
                        break;
                }
                dataFinal[counter][0] = Stream.of(features.toArray(new Double[features.size()])).mapToDouble(Double::doubleValue).toArray();
                dataFinal[counter][1] = targetResult;
                features = new ArrayList<>();
                line = bufferedReader.readLine();
                counter++;
            }
        } finally {
            bufferedReader.close();
        }
        return dataFinal;
    }

    public static Double[] getSelectedFeatures(String data[], Boolean status[]) {
        ArrayList<Double> features = new ArrayList<>();
        if (status[0]) {
            features.add(Double.parseDouble(data[2]) / maxValueOfFeatures[2]);
        }
        if (status[1]) {
            features.add(Double.parseDouble(data[4]) / maxValueOfFeatures[4]);
        }
        if (status[2]) {
            features.add(Double.parseDouble(data[5]) / maxValueOfFeatures[5]);
        }
        if (status[3]) {
            features.add((Double.parseDouble(data[8]) + Double.parseDouble(data[9])) / (maxValueOfFeatures[8] + maxValueOfFeatures[9]));
        }
        if (status[4]) {
            features.add((Double.parseDouble(data[68]) + Double.parseDouble(data[70])) / (maxValueOfFeatures[68] + maxValueOfFeatures[70]));
        }
        if (status[5]) {
            features.add(Double.parseDouble(data[58]) / maxValueOfFeatures[58]);
        }
        if (status[6]) {
            features.add(Double.parseDouble(data[47]) / maxValueOfFeatures[47]);
        }
        if (status[7]) {
            features.add(Double.parseDouble(data[21]) / maxValueOfFeatures[21]);
        }
        if (status[8]) {
            features.add(Double.parseDouble(data[20]) / maxValueOfFeatures[20]);
        }
        if (status[9]) {
            features.add(Double.parseDouble(data[7]) / maxValueOfFeatures[7]);
        }
        if (status[10]) {
            features.add(Double.parseDouble(data[22]) / maxValueOfFeatures[22]);
        }
        if (status[11]) {
            features.add(Double.parseDouble(data[23]) / maxValueOfFeatures[23]);
        }
        if (status[12]) {
            features.add((Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9])));
        }
        if (status[13]) {
            features.add((Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70])));
        }
        if (status[14]) {
            features.add((Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31])));
        }
        if (status[15]) {
            features.add(Double.parseDouble(data[42]) / maxValueOfFeatures[42]);
        }
        if (status[16]) {
            features.add(Double.parseDouble(data[10]) / maxValueOfFeatures[10]);
        }
        if (status[17]) {
            features.add(Double.parseDouble(data[12]) / maxValueOfFeatures[12]);
        }
        if (status[18]) {
            features.add(Double.parseDouble(data[75]) / maxValueOfFeatures[75]);
        }
        if (status[19]) {
            features.add(Double.parseDouble(data[43]) / maxValueOfFeatures[43]);
        }
        if (status[20]) {
            features.add(Double.parseDouble(data[28]) / maxValueOfFeatures[28]);
        }
        if (status[21]) {
            features.add(Double.parseDouble(data[45]) / maxValueOfFeatures[45]);
        }
        if (status[22]) {
            features.add(Double.parseDouble(data[9]) / maxValueOfFeatures[9]);
        }
        if (status[23]) {
            features.add(Double.parseDouble(data[11]) / maxValueOfFeatures[11]);
        }
        if (status[24]) {
            features.add(Double.parseDouble(data[33]) / maxValueOfFeatures[33]);
        }
        if (status[25]) {
            features.add(Double.parseDouble(data[49]) / maxValueOfFeatures[49]);
        }
        if (status[26]) {
            features.add(Double.parseDouble(data[48]) / maxValueOfFeatures[48]);
        }
        return features.toArray(new Double[features.size()]);
    }

    public static void test(String folderName) throws FileNotFoundException, UnsupportedEncodingException, IOException {
        double accuracy = 0;
        double precission = 0;
        double recall = 0;
        NeuralNetwork.truePositive = 0;
        NeuralNetwork.trueNegative = 0;
        NeuralNetwork.falsePositive = 0;
        NeuralNetwork.falseNegative = 0;
        NeuralNetwork.predictAdware = 0;
        NeuralNetwork.predictBenign = 0;
        NeuralNetwork.predictGeneralMalware = 0;
        PrintWriter writer = null;
        PrintWriter writerDetail = null;
        IntStream.range(0, Driver.testingData.length).forEach(i
                -> neuralNetwork.forwardprop(Driver.testingData[i][0], Driver.testingData[i][1])
        );
        accuracy = (double) (NeuralNetwork.trueNegative + NeuralNetwork.truePositive)
                / (double) (NeuralNetwork.trueNegative + NeuralNetwork.truePositive + NeuralNetwork.falseNegative + NeuralNetwork.falsePositive);
        precission = (double) NeuralNetwork.truePositive / (double) (NeuralNetwork.truePositive + NeuralNetwork.falsePositive);
        recall = (double) NeuralNetwork.truePositive / (double) (NeuralNetwork.truePositive + NeuralNetwork.falseNegative);
        System.out.println("True +: " + NeuralNetwork.truePositive);
        System.out.println("True -: " + NeuralNetwork.trueNegative);
        System.out.println("False +: " + NeuralNetwork.falsePositive);
        System.out.println("False -: " + NeuralNetwork.falseNegative);
        System.out.println("Accuracy: " + accuracy);
        System.out.println("Precission: " + precission);
        System.out.println("Recall: " + recall);

        writer = new PrintWriter(new BufferedWriter(new FileWriter("weight/result.txt", true)));
        writerDetail = new PrintWriter(new BufferedWriter(new FileWriter("weight/detail.txt", true)));

        writerDetail.println(folderName);
        writerDetail.println("True +: " + NeuralNetwork.truePositive);
        writerDetail.println("True -: " + NeuralNetwork.trueNegative);
        writerDetail.println("False +: " + NeuralNetwork.falsePositive);
        writerDetail.println("False -: " + NeuralNetwork.falseNegative);
        writerDetail.println("Accuracy: " + accuracy);
        writerDetail.println("Precission: " + precission);
        writerDetail.println("Recall: " + recall);
        writerDetail.println("Predict Benign: " + NeuralNetwork.predictBenign);
        writerDetail.println("Predict Adware: " + NeuralNetwork.predictAdware);
        writerDetail.println("Predict GeneralMalware: " + NeuralNetwork.predictGeneralMalware);
        writerDetail.println();

        writer.println(folderName);

        writer.println(accuracy);
        writer.println(precission);
        writer.println(recall);
        writer.println();

        writer.close();
        writerDetail.close();
    }

    public static void train(String folderName, double learningRate, int hiddenNeurons, int epoch) throws FileNotFoundException, UnsupportedEncodingException {
        PrintWriter writerHiddenOutput = null;
        PrintWriter writerInputHidden = null;
        Neuron[] iNeuron = NeuralNetwork.layers[0].getNeurons();
        Neuron[] hNeuron = NeuralNetwork.layers[1].getNeurons();
        Neuron[] oNeuron = NeuralNetwork.layers[2].getNeurons();
        String pendekatanPath = "weight/" + folderName;
        String parameterNeuralNetworkPath = pendekatanPath + "/LR_" + learningRate + "HN_" + hiddenNeurons + "epoch_" + epoch;
        File directoryPendekatan = new File(pendekatanPath);
        File directoryParameterNeuralNetworkPath = new File(parameterNeuralNetworkPath);

        //Pelatihan sebanyak epoch
        System.out.println(parameterNeuralNetworkPath);
        IntStream.range(0, numberOfEpoch).forEach(i -> {
            System.out.println("[epoch " + i + "]");
            IntStream.range(0, Driver.trainingData.length).forEach(j -> {
                try {
                    Driver.neuralNetwork
                            .forwardprop(Driver.trainingData[j][0], Driver.trainingData[j][1])
                            .backpropError(Driver.trainingData[j][1]);
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Driver.class.getName()).log(Level.SEVERE, null, ex);
                } catch (UnsupportedEncodingException ex) {
                    Logger.getLogger(Driver.class.getName()).log(Level.SEVERE, null, ex);
                }
            });
        });

        //check folder sudah ada atau belum
        if (!directoryPendekatan.exists()) {
            directoryPendekatan.mkdir();
        }
        if (!directoryParameterNeuralNetworkPath.exists()) {
            directoryParameterNeuralNetworkPath.mkdir();
        }

        //write ke dalam file dengan folder sesuai tipenya
        for (int i = 0; i < NeuralNetwork.layers[NeuralNetwork.layers.length - 1].getNeurons().length; i++) {
            writerHiddenOutput = new PrintWriter(parameterNeuralNetworkPath + "/weight_hidden_output_" + (i + 1) + ".txt", "UTF-8");
            for (int j = 0; j < oNeuron[i].getWeights().length; j++) {
                writerHiddenOutput.println(oNeuron[i].getWeights()[j]);
            }
            writerHiddenOutput.close();
        }

        for (int i = 0; i < NeuralNetwork.numbOfHiddenNeurons; i++) {
            writerInputHidden = new PrintWriter(parameterNeuralNetworkPath + "/weight_input_hidden_" + (i + 1) + ".txt", "UTF-8");
            for (int j = 0; j < hNeuron[i].getWeights().length; j++) {
                writerInputHidden.println(hNeuron[i].getWeights()[j]);
            }
            writerInputHidden.close();
        }
        System.out.println("Training has done");
    }
}
