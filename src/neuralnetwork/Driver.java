/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package neuralnetwork;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.IntStream;
import weka.attributeSelection.PrincipalComponents;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;

/**
 * trainingData
 *
 * @author asus
 */
public class Driver {

    static int numberOfEpoch = 100;
    static int numberOfCombinationFeatures[] = {22, 15, 18, 20, 18, 16, 27, 13};
    static int numberOfFeatures = 0;
    static double trainingData[][][];
    static double testingData[][][];
    static double maxValueOfFeatures[];
    static NeuralNetwork neuralNetwork = null;
    static String pendekatan[] = {"PCA", "Literatur", "LiteraturAndByteBased", "LiteraturAndPacketBased",
        "LiteraturAndTimeBased", "LiteraturFlowBased", "LiteraturAndAllBased", "Pengurangan"};
    static double learningRate[] = {0.1, 0.05, 0.01};
    static int hiddenNeuron[] = {4, 5, 6, 12};

    public static void convertToLatex(String file) throws IOException {
        /*
            Function untuk ngeparse output biar langsung ke format table latex
         */

        PrintWriter writer = null;
        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
        writer = new PrintWriter(new BufferedWriter(new FileWriter("latexFormat.txt", true)));
        String line;
        int epoch = 100;
        for (int i = 0; i < 36; i++) {
            String value[] = new String[3];
            double fScore = 0;
            if (i % 9 == 0 && i != 0) {
                writer.println();
            }
            line = bufferedReader.readLine();
            for (int j = 0; j < 3; j++) {
                value[j] = bufferedReader.readLine();
            }
            line = bufferedReader.readLine();
            fScore = getFScore(Double.parseDouble(value[1]), Double.parseDouble(value[2]));
            if (i % 3 == 0 && i != 0) {
                epoch = 100;
            }
            writer.println("& & " + epoch + " & " + String.format("%.2f", 100 * Double.parseDouble(value[0])) + "\\% & " + String.format("%.2f", 100 * Double.parseDouble(value[1]))
                    + "\\% & " + String.format("%.2f", 100 * Double.parseDouble(value[2])) + "\\% & " + String.format("%.4f", fScore) + "\\\\");

            epoch += 100;
        }
        writer.close();
        bufferedReader.close();
    }

    public static double getFScore(double presicion, double recall) {
        /*
            Function untuk f1-score
         */

        double result = 0;
        result = 2 * presicion * recall / (presicion + recall);
        return result;
    }

    public static Instances PCA() {
        String file = "temp.csv";
        Instances transformedData = null;
        try {
            // Load the Data.
            ConverterUtils.DataSource source = new ConverterUtils.DataSource(file);
            Instances data = source.getDataSet();

            // Perform PCA.
            PrincipalComponents pca = new PrincipalComponents();
            pca.setVarianceCovered(1.0);

            pca.setCenterData(false);
            pca.setTransformBackToOriginal(false);
            pca.buildEvaluator(data);

            transformedData = pca.transformedData(data);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return transformedData;
    }

    public static String[] getHeader(String header[], Boolean status[]) {
        ArrayList<String> selectedHeaders = new ArrayList<>();
        int totalFeatures = 0;
        for (int i = 0; i < status.length; i++) {
            if (status[i]) {
                selectedHeaders.add(header[i]);
                totalFeatures++;
            }
        }
        numberOfFeatures = totalFeatures;
        return selectedHeaders.toArray(new String[selectedHeaders.size()]);
    }

    public static void saveToFile(String header[], ArrayList<ArrayList<Double>> dataBeforePCA) throws FileNotFoundException {
        PrintWriter pw = new PrintWriter(new File("temp.csv"));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < header.length - 1; i++) {
            sb.append(header[i]);
            sb.append(',');
        }
        sb.append(header[header.length - 1]);
        sb.append('\n');

        for (int i = 0; i < dataBeforePCA.size(); i++) {
            for (int j = 0; j < dataBeforePCA.get(i).size() - 1; j++) {
                sb.append(dataBeforePCA.get(i).get(j));
                sb.append(',');
            }
            sb.append(dataBeforePCA.get(i).get(dataBeforePCA.get(i).size() - 1));
            sb.append('\n');
        }

        pw.write(sb.toString());
        pw.close();
        System.out.println("Save To File Done!");
    }

    public static double[][][] getData(String file, String type, Boolean status[]) throws IOException {
        /*
            Fungsi buat ambil data dari file
         */

        BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
        ArrayList<Double> features = new ArrayList<>();
        ArrayList<ArrayList<Double>> dataBeforePCA = new ArrayList<>();
        String line; // for read every line
        String[] header;
        String dataAfterSplit[];
        String result = "";
        double dataAfterPCA[][][];
        double targetResult[];
        int counter = 0;
        int totalData = 0;

        line = bufferedReader.readLine();
        header = line.split(",");
        header = getHeader(header, status);

        try {
            while (line != null) {
                totalData++;
                line = bufferedReader.readLine();
            }
            /* [counter - 1] = total data, [2] = features and target results, [maxValueOfFeatures.length] = number of features*/
            dataAfterPCA = new double[totalData - 1][2][numberOfFeatures];
            bufferedReader = new BufferedReader(new FileReader(file));
            line = bufferedReader.readLine();
            line = bufferedReader.readLine();

            while (line != null) {
                dataAfterSplit = line.split(",");
                targetResult = new double[3];
                result = dataAfterSplit[dataAfterSplit.length - 1];

                if (type.equals("All")) {
                    for (int i = 0; i < dataAfterSplit.length - 1; i++) {
                        features.add(Double.parseDouble(dataAfterSplit[i]) / maxValueOfFeatures[i]);
                    }
                } else {
                    Double temp[] = getSelectedFeatures(dataAfterSplit, status);
                    numberOfFeatures = temp.length;
                    for (int i = 0; i < temp.length; i++) {
                        features.add(temp[i]);
                    }
                }

                switch (result) {
                    case "benign":
                        targetResult[0] = 1;
                        targetResult[1] = 0;
                        targetResult[2] = 0;
                        break;
                    case "asware":
                        targetResult[0] = 0;
                        targetResult[1] = 1;
                        targetResult[2] = 0;
                        break;
                    case "GeneralMalware":
                        targetResult[0] = 0;
                        targetResult[1] = 0;
                        targetResult[2] = 1;
                        break;
                    default:
                        break;
                }
//                data[counter][0] = Stream.of(features.toArray(new Double[features.size()])).mapToDouble(Double::doubleValue).toArray();
                dataAfterPCA[counter][1] = targetResult;
                dataBeforePCA.add(features);
                features = new ArrayList<>();
                line = bufferedReader.readLine();
                counter++;
            }

            saveToFile(header, dataBeforePCA);
            setMaxValueOfFeatures(PCA());

        } finally {
            bufferedReader.close();
        }

        return dataAfterPCA;
    }

    public static Double[] getSelectedFeatures(String data[], Boolean status[]) {
        ArrayList<Double> features = new ArrayList<>();
        if (status[0]) {
            features.add(Double.parseDouble(data[2]));
        }
        if (status[1]) {
            features.add(Double.parseDouble(data[4]));
        }
        if (status[2]) {
            features.add((Double.parseDouble(data[8]) + Double.parseDouble(data[9])));
        }
        if (status[3]) {
            features.add((Double.parseDouble(data[68]) + Double.parseDouble(data[70])));
        }
        if (status[4]) {
            features.add(Double.parseDouble(data[58]));
        }
        if (status[5]) {
            features.add(Double.parseDouble(data[47]));
        }
        if (status[6]) {
            features.add(Double.parseDouble(data[21]));
        }
        if (status[7]) {
            features.add(Double.parseDouble(data[20]));
        }
        if (status[8]) {
            features.add(Double.parseDouble(data[22]));
        }
        if (status[9]) {
            features.add(Double.parseDouble(data[23]));
        }
        if (status[10]) {
            features.add((Double.parseDouble(data[8]) / Double.parseDouble(data[9]) == 0 ? 1 : Double.parseDouble(data[9])));
        }
        if (status[11]) {
            features.add((Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70])));
        }
        if (status[12]) {
            features.add((Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31])));
        }
        if (status[13]) {
            features.add((Double.parseDouble(data[68]) / Double.parseDouble(data[70]) == 0 ? 1 : Double.parseDouble(data[70])));
        }
        if (status[14]) {
            features.add((Double.parseDouble(data[26]) / Double.parseDouble(data[31]) == 0 ? 1 : Double.parseDouble(data[31])));
        }
        if (status[15]) {
            features.add(Double.parseDouble(data[49]));
        }
        if (status[16]) {
            features.add(Double.parseDouble(data[75]));
        }
        if (status[17]) {
            features.add(Double.parseDouble(data[28]));
        }
        if (status[18]) {
            features.add(Double.parseDouble(data[33]));
        }
        if (status[19]) {
            features.add(Double.parseDouble(data[42]) / maxValueOfFeatures[42]);
        }
        if (status[20]) {
            features.add(Double.parseDouble(data[10]) / maxValueOfFeatures[10]);
        }
        if (status[21]) {
            features.add(Double.parseDouble(data[43]) / maxValueOfFeatures[43]);
        }
        if (status[22]) {
            features.add(Double.parseDouble(data[45]) / maxValueOfFeatures[45]);
        }
        if (status[23]) {
            features.add(Double.parseDouble(data[9]) / maxValueOfFeatures[9]);
        }
        if (status[24]) {
            features.add(Double.parseDouble(data[11]) / maxValueOfFeatures[11]);
        }
        if (status[25]) {
            features.add(Double.parseDouble(data[12]) / maxValueOfFeatures[12]);
        }
        if (status[26]) {
            features.add(Double.parseDouble(data[48]) / maxValueOfFeatures[48]);
        }
        return features.toArray(new Double[features.size()]);
    }

    public static int getNumberOfEpoch() {
        return numberOfEpoch;
    }

    public static void setNumberOfEpoch(int numberOfEpoch) {
        Driver.numberOfEpoch = numberOfEpoch;
    }

    public static int[] getNumberOfCombinationFeatures() {
        return numberOfCombinationFeatures;
    }

    public static void setNumberOfCombinationFeatures(int[] numberOfCombinationFeatures) {
        Driver.numberOfCombinationFeatures = numberOfCombinationFeatures;
    }

    public static double[][][] getTrainingData() {
        return trainingData;
    }

    public static void setTrainingData(double[][][] trainingData) {
        Driver.trainingData = trainingData;
    }

    public static double[][][] getTestingData() {
        return testingData;
    }

    public static void setTestingData(double[][][] testingData) {
        Driver.testingData = testingData;
    }

    public static double[] getMaxValueOfFeatures() {
        return maxValueOfFeatures;
    }

    public static void setMaxValueOfFeatures(Instances maxValueOfFeatures) {

        String temp[] = maxValueOfFeatures.get(0).toString().split(",");
        int totalFeatures = temp.length;
        double maxValue[] = new double[totalFeatures];

        for (int i = 0; i < maxValueOfFeatures.size(); i++) {
            temp = maxValueOfFeatures.get(i).toString().split(",");
            for (int j = 0; j < totalFeatures; j++) {
                if (maxValue[j] < Double.parseDouble(temp[j])) {
                    maxValue[j] = Double.parseDouble(temp[j]);
                }
            }
        }
        Driver.maxValueOfFeatures = maxValue;
    }

    public static NeuralNetwork getNeuralNetwork() {
        return neuralNetwork;
    }

    public static void setNeuralNetwork(NeuralNetwork neuralNetwork) {
        Driver.neuralNetwork = neuralNetwork;
    }

    public static String[] getPendekatan() {
        return pendekatan;
    }

    public static void setPendekatan(String[] pendekatan) {
        Driver.pendekatan = pendekatan;
    }

    public static double[] getLearningRate() {
        return learningRate;
    }

    public static void setLearningRate(double[] learningRate) {
        Driver.learningRate = learningRate;
    }

    public static int[] getHiddenNeuron() {
        return hiddenNeuron;
    }

    public static void setHiddenNeuron(int[] hiddenNeuron) {
        Driver.hiddenNeuron = hiddenNeuron;
    }

    public static void test(int indexPendekatan, int indexLearningRate, int indexHiddenNeuron, int epoch) throws FileNotFoundException, UnsupportedEncodingException, IOException {
        double accuracy = 0;
        double precission = 0;
        double recall = 0;
        NeuralNetwork.truePositive = 0;
        NeuralNetwork.trueNegative = 0;
        NeuralNetwork.falsePositive = 0;
        NeuralNetwork.falseNegative = 0;
        NeuralNetwork.predictAdware = 0;
        NeuralNetwork.predictBenign = 0;
        NeuralNetwork.predictGeneralMalware = 0;
        PrintWriter writer = null;
        PrintWriter writerDetail = null;
        IntStream.range(0, Driver.trainingData.length).forEach(i
                -> neuralNetwork.forwardprop(Driver.trainingData[i][0], Driver.trainingData[i][1])
        );

        accuracy = (double) (NeuralNetwork.trueNegative + NeuralNetwork.truePositive)
                / (double) (NeuralNetwork.trueNegative + NeuralNetwork.truePositive + NeuralNetwork.falseNegative + NeuralNetwork.falsePositive);
        precission = (double) NeuralNetwork.truePositive / (double) (NeuralNetwork.truePositive + NeuralNetwork.falsePositive);
        recall = (double) NeuralNetwork.truePositive / (double) (NeuralNetwork.truePositive + NeuralNetwork.falseNegative);
        System.out.println("True +: " + NeuralNetwork.truePositive);
        System.out.println("True -: " + NeuralNetwork.trueNegative);
        System.out.println("False +: " + NeuralNetwork.falsePositive);
        System.out.println("False -: " + NeuralNetwork.falseNegative);
        System.out.println("Accuracy: " + accuracy);
        System.out.println("Precission: " + precission);
        System.out.println("Recall: " + recall);
        writer = new PrintWriter(new BufferedWriter(new FileWriter("weight/result.txt", true)));
        writerDetail = new PrintWriter(new BufferedWriter(new FileWriter("weight/detail.txt", true)));

        writerDetail.println(pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch);
        writerDetail.println("True +: " + NeuralNetwork.truePositive);
        writerDetail.println("True -: " + NeuralNetwork.trueNegative);
        writerDetail.println("False +: " + NeuralNetwork.falsePositive);
        writerDetail.println("False -: " + NeuralNetwork.falseNegative);
        writerDetail.println("Accuracy: " + accuracy);
        writerDetail.println("Precission: " + precission);
        writerDetail.println("Recall: " + recall);
        writerDetail.println("Predict Benign: " + NeuralNetwork.predictBenign);
        writerDetail.println("Predict Adware: " + NeuralNetwork.predictAdware);
        writerDetail.println("Predict GeneralMalware: " + NeuralNetwork.predictGeneralMalware);
        writerDetail.println();

        writer.println(pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch);

        writer.println(accuracy);
        writer.println(precission);
        writer.println(recall);
        writer.println();

        writer.close();
        writerDetail.close();
    }

    public static void train(int indexPendekatan, int indexLearningRate, int indexHiddenNeuron, int epoch) throws FileNotFoundException, UnsupportedEncodingException {
        PrintWriter writerHiddenOutput = null;
        PrintWriter writerInputHidden = null;
        Neuron[] iNeuron = NeuralNetwork.layers[0].getNeurons();
        Neuron[] hNeuron = NeuralNetwork.layers[1].getNeurons();
        Neuron[] oNeuron = NeuralNetwork.layers[2].getNeurons();
        String pendekatanPath = "weight/" + pendekatan[indexPendekatan];
        File directoryPendekatan = new File(pendekatanPath);

        //Pelatihan sebanyak epoch
        IntStream.range(0, numberOfEpoch).forEach(i -> {
            System.out.println("[epoch " + i + "]");
            IntStream.range(0, Driver.trainingData.length).forEach(j -> {
                try {
                    Driver.neuralNetwork
                            .forwardprop(Driver.trainingData[j][0], Driver.trainingData[j][1])
                            .backpropError(Driver.trainingData[j][1]);
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Driver.class.getName()).log(Level.SEVERE, null, ex);
                } catch (UnsupportedEncodingException ex) {
                    Logger.getLogger(Driver.class.getName()).log(Level.SEVERE, null, ex);
                }
            });
        });

        //check folder sudah ada atau belum
        if (!directoryPendekatan.exists()) {
            directoryPendekatan.mkdir();
        }

        //write ke dalam file dengan folder sesuai tipenya
        for (int i = 0; i < NeuralNetwork.layers[NeuralNetwork.layers.length - 1].getNeurons().length; i++) {
            String path = "weight/" + pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                    + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch;
            File directory = new File(path);
            if (!directory.exists()) {
                directory.mkdir();
            }
            writerHiddenOutput = new PrintWriter(path + "/weight_hidden_output_" + (i + 1) + ".txt", "UTF-8");
            for (int j = 0; j < oNeuron[i].getWeights().length; j++) {
                writerHiddenOutput.println(oNeuron[i].getWeights()[j]);
            }
            writerHiddenOutput.close();
        }

        for (int i = 0; i < NeuralNetwork.numbOfHiddenNeurons; i++) {
            String path = "weight/" + pendekatan[indexPendekatan] + "/LR_" + learningRate[indexLearningRate]
                    + "HN_" + hiddenNeuron[indexHiddenNeuron] + "epoch_" + epoch;

            writerInputHidden = new PrintWriter(path + "/weight_input_hidden_" + (i + 1) + ".txt", "UTF-8");
            for (int j = 0; j < hNeuron[i].getWeights().length; j++) {
                writerInputHidden.println(hNeuron[i].getWeights()[j]);
            }
            writerInputHidden.close();
        }
        System.out.println("Training has done");
    }

    public static void main(String[] args) throws IOException {
//        convertToLatex("nonLatex.txt");
        int epoch = 100;
        String fileTraining[] = {"PCATraining.csv", "TrainingData.csv"};
        String fileTesting[] = {"PCATesting.csv", "TestingData.csv"};
//        "PCA", "Literatur", "LiteraturAndByteBased", "LiteraturAndPacketBased",
//        "LiteraturAndTimeBased", "LiteraturFlowBased", "LiteraturAndAllBased", "Pengurangan"
        for (int i = 2; i < 3; i++) {
            /*
                int i = 7;//pendekatan
                int k = 3;//hidden neuron
                int j = 1;//learning rate
             */
            if (i == 0) {
                trainingData = getData(fileTraining[0], pendekatan[i], numberOfCombinationFeatures[i]);
                testingData = getData(fileTesting[0], pendekatan[i], numberOfCombinationFeatures[i]);
            } else {
                trainingData = getData(fileTraining[1], pendekatan[i], numberOfCombinationFeatures[i]);
                testingData = getData(fileTesting[1], pendekatan[i], numberOfCombinationFeatures[i]);
            }
            for (int k = 0; k < hiddenNeuron.length; k++) {
                for (int j = 0; j < learningRate.length; j++) {

                    NeuralNetwork.LEARNING_RATE = learningRate[j];
                    NeuralNetwork.numbOfHiddenNeurons = hiddenNeuron[k];

                    neuralNetwork = new NeuralNetwork();
                    System.out.println(pendekatan[i] + " LR: " + learningRate[j] + " hidden neuron: " + hiddenNeuron[k] + " epoch: " + epoch);
                    train(i, j, k, epoch);
                    test(i, j, k, epoch);
                    System.out.println(pendekatan[i] + " LR: " + learningRate[j] + " hidden neuron: " + hiddenNeuron[k] + " epoch: " + (epoch + 100));
                    train(i, j, k, epoch + 100);
                    test(i, j, k, epoch + 100);
                    System.out.println(pendekatan[i] + " LR: " + learningRate[j] + " hidden neuron: " + hiddenNeuron[k] + " epoch: " + (epoch + 200));
                    train(i, j, k, epoch + 200);
                    test(i, j, k, epoch + 200);
                }
            }
        }
    }
}
